/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/v1/info/chains": {
    /** @description Get all supported chains along with additional data useful for building applications + frontends that interface with them (e.g. logo URI, IBC capabilities, fee assets, bech32 prefix, etc...) */
    get: operations["getChains"];
  };
  "/v2/info/bridges": {
    /** @description Get all supported bridges */
    get: operations["getBridges"];
  };
  "/v1/fungible/venues": {
    /** @description Get supported swap venues. */
    get: operations["getVenues"];
  };
  "/v1/fungible/assets": {
    /** @description Get supported assets. Optionally limit to assets on a given chain and/or native assets. */
    get: operations["getAssets"];
  };
  "/v1/fungible/assets_from_source": {
    /** @description Get assets that can be reached from a source via transfers under different conditions (e.g. single vs multiple txs) */
    post: operations["getAssetsFromSource"];
  };
  "/v2/fungible/route": {
    /** @description This supports cross-chain actions among EVM chains, Cosmos chains, and between them. Returns the sequence of transfers and/or swaps to reach the given destination asset from the given source asset, along with estimated amount out. Commonly called before /msgs to generate route info and quote. */
    post: operations["getRouteV2"];
  };
  "/v2/fungible/msgs": {
    /** @description This supports cross-chain actions among EVM chains, Cosmos chains, and between them. Returns minimal number of messages required to execute a multi-chain swap or transfer. Input consists of the output of route with additional information required for message construction (e.g. destination addresses for each chain) */
    post: operations["getMsgsV2"];
  };
  "/v2/fungible/msgs_direct": {
    /** @description This supports cross-chain actions among EVM chains, Cosmos chains, and between them. Returns minimal number of messages required to execute a multi-chain swap or transfer. This is a convenience endpoint that combines /route and /msgs into a single call. */
    post: operations["getMsgsDirectV2"];
  };
  "/v1/fungible/recommend_assets": {
    /** @description Request asset recommendations for the given source assets on a given destination chain. The response includes recommended destination assets and recommendation reasons. */
    post: operations["getAssetRecommendations"];
  };
  "/v2/tx/submit": {
    /** @description Submit a signed base64 encoded transaction to be broadcast to the specified network. On successful submission, the status of the transaction and any subsequent IBC or Axelar transfers can be queried through the /status endpoint. */
    post: operations["submitTransactionV2"];
  };
  "/v2/tx/track": {
    /** @description Requests tracking of a transaction that has already landed on-chain but was not broadcast through the skip api. The status of a tracked transaction and subsequent IBC or Axelar transfers if routing assets cross chain can be queried through the /status endpoint. */
    post: operations["trackTransactionV2"];
  };
  "/v2/tx/status": {
    /** @description Get the status of the specified transaction and any subsequent IBC or Axelar transfers if routing assets cross chain. The transaction must have previously been submitted to either the /submit or /track endpoints. */
    get: operations["getTransactionStatusV2"];
  };
  "/v1/fungible/ibc_origin_assets": {
    /** @description Get origin assets from a given list of denoms and chain ids. */
    post: operations["getOriginAssets"];
  };
  "/v2/fungible/assets_between_chains": {
    /** @description Given 2 chain ids, returns a list of equivalent assets that can be transferred */
    post: {
      requestBody: {
        content: {
          "application/json": {
            /** @description Chain-id of the source chain */
            source_chain_id?: string;
            /** @description Chain-id of the destination chain */
            dest_chain_id?: string;
            /**
             * @description Whether to include assets without metadata (symbol, name, logo_uri, etc.)
             * @default false
             */
            include_no_metadata_assets?: boolean;
            /**
             * @description Whether to include CW20 tokens
             * @default false
             */
            include_cw20_assets?: boolean;
            /**
             * @description Whether to include EVM tokens
             * @default false
             */
            include_evm_assets?: boolean;
            /**
             * @description Whether to include recommendations requiring multiple transactions to reach the destination
             * @default false
             */
            allow_multi_tx?: boolean;
          };
        };
      };
      responses: {
        /** @description OK */
        200: {
          content: {
            "application/json": {
              assets_between_chains?: components["schemas"]["AssetBetweenChains"][];
            };
          };
        };
        /** @description One of the chain ids was not found */
        404: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
        /** @description Internal server error */
        500: {
          content: {
            "application/json": components["schemas"]["Error"];
          };
        };
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    AcknowledgementErrorDetails: {
      /** @description Error code */
      code?: number;
      /** @description Error message */
      message?: string;
    };
    /** @description An affiliate that receives fees from a swap */
    Affiliate: {
      /** @description Address to which to pay the fee */
      address?: string;
      /** @description Bps fee to pay to the affiliate */
      basis_points_fee?: string;
    };
    ApiError: {
      /** @description Error message */
      message?: string;
    };
    Asset: {
      /** @description Chain-id of the asset */
      chain_id?: string;
      /** @description Coingecko id of the asset */
      coingecko_id?: string | null;
      /** @description Number of decimals used for amounts of the asset */
      decimals?: number | null;
      /** @description Denom of the asset */
      denom?: string;
      /** @description Description of the asset */
      description?: string | null;
      /** @description Indicates whether asset is a CW20 token */
      is_cw20?: boolean;
      /** @description Indicates whether asset is an EVM token */
      is_evm?: boolean;
      /** @description URI pointing to an image of the logo of the asset */
      logo_uri?: string | null;
      /** @description Name of the asset */
      name?: string | null;
      /** @description Chain-id of the origin of the asset. If this is an ibc denom, this is the chain-id of the asset that the ibc token represents */
      origin_chain_id?: string;
      /** @description Denom of the origin of the asset. If this is an ibc denom, this is the original denom that the ibc token represents */
      origin_denom?: string;
      /** @description Recommended symbol of the asset used to differentiate between bridged assets with the same symbol, e.g. USDC.axl for Axelar USDC and USDC.grv for Gravity USDC */
      recommended_symbol?: string | null;
      /** @description Symbol of the asset, e.g. ATOM for uatom */
      symbol?: string | null;
      /** @description Address of the contract for the asset, e.g. if it is a CW20 or ERC20 token */
      token_contract?: string | null;
      /** @description The forward slash delimited sequence of ibc ports and channels that can be traversed to unwind an ibc token to its origin asset. */
      trace?: string;
    };
    AssetBetweenChains: {
      asset_on_source?: components["schemas"]["Asset"];
      asset_on_dest?: components["schemas"]["Asset"];
      /** @description Number of transactions required to transfer the asset */
      txs_required?: number;
      /** @description Bridges that are used to transfer the asset */
      bridges?: components["schemas"]["BridgeType"][];
    };
    AssetRecommendation: {
      /** @description Asset that is recommended */
      asset?: components["schemas"]["Asset"];
      /** @description Reason for recommending the asset */
      reason?: components["schemas"]["Reason"];
    };
    /** @enum {string} */
    AutopilotAction: "LIQUID_STAKE" | "CLAIM";
    AutopilotMsg: {
      action?: components["schemas"]["AutopilotAction"];
      receiver?: string;
    };
    AutopilotMsgWrapper: {
      autpilot_msg?: components["schemas"]["AutopilotMsg"];
    };
    /** @description A transfer facilitated by the Axelar bridge */
    AxelarTransfer: {
      /** @description Axelar-name of the asset to bridge */
      asset?: string;
      /** @description Amount of the fee asset to be paid as the Axelar bridge fee. This is denominated in the fee asset. */
      fee_amount?: string;
      fee_asset?: components["schemas"]["Asset"];
      /** @description Name for source chain of the bridge transaction used on Axelar */
      from_chain?: string;
      /** @description Canonical chain-id of the source chain of the bridge transaction */
      from_chain_id?: string;
      /** @description Whether the source and destination chains are both testnets */
      is_testnet?: boolean;
      /** @description Whether to unwrap the asset at the destination chain (from ERC-20 to native) */
      should_unwrap?: boolean;
      /** @description Name for destination chain of the bridge transaction used on Axelar */
      to_chain?: string;
      /** @description Canonical chain-id of the destination chain of the bridge transaction */
      to_chain_id?: string;
      /** @description Amount of the fee asset to be paid as the Axelar bridge fee, converted to USD value */
      usd_fee_amount?: string;
      ibc_transfer_to_axelar?: components["schemas"]["Transfer"];
      bridge_id?: components["schemas"]["BridgeType"];
    };
    AxelarTransferInfo: {
      axelar_transfer?: {
        /** @description Link to the transaction on the Axelar Scan explorer */
        axelar_scan_link?: string;
        /** @description Chain ID of the destination chain */
        dst_chain_id?: string;
        /** @description Chain ID of the source chain */
        src_chain_id?: string;
        state?: components["schemas"]["AxelarTransferState"];
        txs?: components["schemas"]["ContractCallWithTokenTxs"] | components["schemas"]["SendTokenTxs"];
        type?: components["schemas"]["AxelarTransferType"];
      };
    };
    /**
     * @description Axelar transfer state: <br/> * AXELAR_TRANSFER_UNKNOWN - Unknown error <br/> * AXELAR_TRANSFER_PENDING_CONFIRMATION - Axelar transfer is pending confirmation <br/> * AXELAR_TRANSFER_PENDING_RECEIPT - Axelar transfer is pending receipt at destination <br/> * AXELAR_TRANSFER_SUCCESS - Axelar transfer succeeded and assets have been received <br/> * AXELAR_TRANSFER_FAILURE - Axelar transfer failed <br/>
     *
     * @enum {string}
     */
    AxelarTransferState: "AXELAR_TRANSFER_UNKNOWN" | "AXELAR_TRANSFER_PENDING_CONFIRMATION" | "AXELAR_TRANSFER_PENDING_RECEIPT" | "AXELAR_TRANSFER_SUCCESS" | "AXELAR_TRANSFER_FAILURE";
    /**
     * @description Axelar transfer type: <br/> * AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN - GMP contract call with token transfer type <br/> * AXELAR_TRANSFER_SEND_TOKEN - Send token transfer type <br/>
     *
     * @enum {string}
     */
    AxelarTransferType: "AXELAR_TRANSFER_CONTRACT_CALL_WITH_TOKEN" | "AXELAR_TRANSFER_SEND_TOKEN";
    AxelarTransferWrapper: {
      axelar_transfer?: components["schemas"]["AxelarTransfer"];
    };
    /** @description A transfer facilitated by the CCTP bridge */
    CCTPTransfer: {
      /** @description Canonical chain-id of the source chain of the bridge transaction */
      from_chain_id?: string;
      /** @description Canonical chain-id of the destination chain of the bridge transaction */
      to_chain_id?: string;
      /** @description Name of the asset to bridge. It will be the erc-20 contract address for EVM chains and `uusdc` for Noble. */
      burn_token?: string;
      bridge_id?: components["schemas"]["BridgeType"];
    };
    CCTPTransferInfo: {
      cctp_transfer?: {
        /** @description Chain ID of the destination chain */
        dst_chain_id?: string;
        /** @description Chain ID of the source chain */
        src_chain_id?: string;
        state?: components["schemas"]["CCTPTransferState"];
        txs?: components["schemas"]["CCTPTransferTxs"];
      };
    };
    CCTPTransferTxs: {
      send_tx?: components["schemas"]["PacketTransaction"] | null;
      receive_tx?: components["schemas"]["PacketTransaction"] | null;
    };
    /**
     * @description CCTP transfer state: <br/> * CCTP_TRANSFER_UNKNOWN - Unknown error <br/> * CCTP_TRANSFER_SENT - The burn transaction on the source chain has executed <br/> * CCTP_TRANSFER_PENDING_CONFIRMATION - CCTP transfer is pending confirmation by the cctp attestation api <br/> * CCTP_TRANSFER_CONFIRMED - CCTP transfer has been confirmed by the cctp attestation api <br/> * CCTP_TRANSFER_RECEIVED - CCTP transfer has been received at the destination chain
     * @enum {string}
     */
    CCTPTransferState: "CCTP_TRANSFER_UNKNOWN" | "CCTP_TRANSFER_SENT" | "CCTP_TRANSFER_PENDING_CONFIRMATION" | "CCTP_TRANSFER_CONFIRMED" | "CCTP_TRANSFER_RECEIVED";
    CCTPTransferWrapper: {
      cctp_transfer?: components["schemas"]["CCTPTransfer"];
    };
    BankSend: Record<string, never>;
    BankSendWrapper: {
      bank_send?: components["schemas"]["BankSend"];
    };
    Bridge: {
      id?: components["schemas"]["BridgeType"];
      /** @description Name of the bridge */
      name?: string;
      /** @description URI pointing to an image of the logo of the bridge */
      logo_uri?: string;
    };
    /**
     * @description Bridge Type: <br/> * IBC - IBC Bridge <br/> * AXELAR - Axelar Bridge <br/> * CCTP - CCTP Bridge
     * @enum {unknown}
     */
    BridgeType: "IBC" | "AXELAR" | "CCTP";
    Chain: {
      /** @description Name of the chain */
      chain_name?: string;
      /** @description Chain-id of the chain */
      chain_id?: string;
      /** @description Whether the PFM module is enabled on the chain */
      pfm_enabled?: boolean;
      /** @description Supported cosmos modules */
      cosmos_module_support?: components["schemas"]["CosmosModuleSupport"];
      /** @description Whether the chain supports IBC memos */
      supports_memo?: boolean;
      /** @description chain logo URI */
      logo_uri?: string | null;
      /** @description Bech32 prefix of the chain */
      bech32_prefix?: string;
      /** @description Fee assets of the chain */
      fee_assets?: components["schemas"]["FeeAsset"][];
      /** @description Type of chain, e.g. "cosmos" or "evm" */
      chain_type?: string;
      /** @description IBC capabilities of the chain */
      ibc_capabilities?: components["schemas"]["IbcCapabilities"];
    };
    ContractCallWithTokenError: {
      /** @description Error message */
      message?: string;
      type?: components["schemas"]["ContractCallWithTokenErrorType"];
    };
    /**
     * @description ContractCallWithToken errors: <br/> * CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR - Error occurred during the execute transaction <br/>
     *
     * @enum {string}
     */
    ContractCallWithTokenErrorType: "CONTRACT_CALL_WITH_TOKEN_EXECUTION_ERROR";
    ContractCallWithTokenTxs: {
      approve_tx?: components["schemas"]["PacketTransaction"] | null;
      confirm_tx?: components["schemas"]["PacketTransaction"] | null;
      error?: components["schemas"]["ContractCallWithTokenError"] | null;
      execute_tx?: components["schemas"]["PacketTransaction"] | null;
      gas_paid_tx?: components["schemas"]["PacketTransaction"] | null;
      send_tx?: components["schemas"]["PacketTransaction"] | null;
    };
    CosmWasmContractMsg: {
      /** @description Address of the contract to execute the message on */
      contract_address?: string;
      /** @description JSON string of the message */
      msg?: string;
    };
    CosmWasmContractMsgWrapper: {
      wasm_msg?: components["schemas"]["CosmWasmContractMsg"];
    };
    /** @description An ERC20 token contract approval */
    Erc20Approval: {
      /** @description Amount of the approval */
      amount?: string;
      /** @description Address of the spender */
      spender?: string;
      /** @description Address of the ERC20 token contract */
      token_contract?: string;
    };
    ErrorDetail: {
      /**
       * @description Error detail: <br/> * LOW_INFO_ERROR - Not enough asset pricing information to determine the price safety of the route. <br/> * BAD_PRICE_ERROR - The execution price of the route deviates significantly from the current market price.
       * @enum {string}
       */
      reason?: "LOW_INFO_ERROR" | "BAD_PRICE_ERROR";
    };
    Error: {
      /** @description Error code */
      code?: components["schemas"]["GRPCStatusCode"];
      /** @description Additional error details */
      details?: components["schemas"]["ErrorDetail"][];
      /** @description Error message */
      message?: string;
    };
    /** @description A transaction on an EVM chain */
    EvmTx: {
      /** @description Chain-id of the chain that the transaction is intended for */
      chain_id?: string;
      /** @description Data of the transaction */
      data?: string;
      /** @description ERC20 approvals required for the transaction */
      required_erc20_approvals?: components["schemas"]["Erc20Approval"][];
      /** @description Address of the recipient of the transaction */
      to?: string;
      /** @description Amount of the transaction */
      value?: string;
    };
    EvmTxWrapper: {
      evm_tx?: components["schemas"]["EvmTx"];
    };
    /** @description Asset used to pay gas fees and the recommended price tiers. Assets and gas price recommendations are sourced from the [keplr chain registry](https://github.com/chainapsis/keplr-chain-registry) */
    FeeAsset: {
      /** @description Asset denom */
      denom?: string;
      /** @description Gas price tiers */
      gas_price_info?: {
        /** @description Average gas price */
        average?: string;
        /** @description High gas price */
        high?: string;
        /** @description Low gas price */
        low?: string;
      } | null;
    };
    /** @description grpc status codes as defined [here](https://grpc.github.io/grpc/core/md_doc_statuscodes.html) */
    GRPCStatusCode: number;
    IBCTransferInfo: {
      ibc_transfer?: components["schemas"]["TransferInfo"];
    };
    Msg: components["schemas"]["MultiChainMsgWrapper"] | components["schemas"]["EvmTxWrapper"];
    /** @description A message that interacts with multiple chains */
    MultiChainMsg: {
      /** @description Chain-id of the chain that the transaction containing the message is intended for */
      chain_id?: string;
      /** @description JSON string of the message */
      msg?: string;
      /** @description TypeUrl of the message */
      msg_type_url?: string;
      /** @description Path of chain-ids that the message is intended to interact with */
      path?: string[];
    };
    MultiChainMsgWrapper: {
      multi_chain_msg?: components["schemas"]["MultiChainMsg"];
    };
    Operation: components["schemas"]["TransferWrapper"] | components["schemas"]["SwapWrapper"] | components["schemas"]["AxelarTransferWrapper"] | components["schemas"]["BankSendWrapper"] | components["schemas"]["CCTPTransferWrapper"];
    OptionalAsset: {
      asset?: components["schemas"]["Asset"];
      /** @description Whether the asset was found */
      asset_found?: boolean;
    };
    Packet: {
      acknowledge_tx?: components["schemas"]["PacketTransaction"] | null;
      error?: components["schemas"]["PacketError"] | null;
      receive_tx?: components["schemas"]["PacketTransaction"] | null;
      send_tx?: components["schemas"]["PacketTransaction"] | null;
      timeout_tx?: components["schemas"]["PacketTransaction"] | null;
    };
    PacketError: {
      details?: unknown;
      /** @description Error message */
      message?: string;
      type?: components["schemas"]["PacketErrorType"];
    };
    /**
     * @description Packet error type: <br/> * PACKET_ERROR_UNKNOWN - Unknown error <br/> * PACKET_ERROR_ACKNOWLEDGEMENT - Packet acknowledgement error <br/> * PACKET_ERROR_TIMEOUT - Packet timed out <br/>
     *
     * @enum {string}
     */
    PacketErrorType: "PACKET_ERROR_UNKNOWN" | "PACKET_ERROR_ACKNOWLEDGEMENT" | "PACKET_ERROR_TIMEOUT";
    PacketTransaction: {
      /** @description Chain ID the packet event occurs on */
      chain_id?: string;
      /** @description Link to the transaction on block explorer */
      explorer_link?: string;
      /** @description Hash of the transaction the packet event occurred in */
      tx_hash?: string;
    };
    PostHandler: components["schemas"]["CosmWasmContractMsgWrapper"] | components["schemas"]["AutopilotMsgWrapper"];
    /**
     * @description Recommendation reason: <br/> * UNKNOWN - Unknown recommendation reason. <br/> * MOST_LIQUID - Highest liquidity form of the transferred token on the destination chain. <br/> * BASE_TOKEN - The base token if the destination chain is the origin chain of the source token. <br/> * DIRECT - The token resulting from the least amount of transfers to the destination chain.
     *
     * @enum {string}
     */
    Reason: "UNKNOWN" | "MOST_LIQUID" | "BASE_TOKEN" | "DIRECT";
    /**
     * @description Recommendation reason: <br/> * LOW_INFO_WARNING - Not enough asset pricing information to determine the price safety of the route. <br/> * BAD_PRICE_WARNING - The execution price of the route deviates significantly from the current market price.
     * @enum {string}
     */
    RoutePriceWarningType: "LOW_INFO_WARNING" | "BAD_PRICE_WARNING";
    RouteResponse: {
      /** @description Amount of source asset to be transferred or swapped */
      amount_in?: string;
      /** @description Amount of destination asset out */
      amount_out?: string;
      /** @description Chain-ids of all chains of the transfer or swap, in order of usage by operations in the route */
      chain_ids?: string[];
      /** @description Chain-id of the destination asset */
      dest_asset_chain_id?: string;
      /** @description Denom of the destination asset */
      dest_asset_denom?: string;
      /** @description Whether this route performs a swap */
      does_swap?: boolean;
      /** @description Amount of destination asset out, if a swap is performed */
      estimated_amount_out?: string;
      /** @description Array of operations required to perform the transfer or swap */
      operations?: components["schemas"]["Operation"][];
      /** @description Chain-id of the source asset */
      source_asset_chain_id?: string;
      /** @description Denom of the source asset */
      source_asset_denom?: string;
      /** @description Swap venue on which the swap is performed, if a swap is performed */
      swap_venue?: components["schemas"]["SwapVenue"];
      /** @description Number of transactions required to perform the transfer or swap */
      txs_required?: number;
      /** @description Amount of the source denom, converted to USD value */
      usd_amount_in?: string;
      /** @description Amount of the destination denom expected to be received, converted to USD value */
      usd_amount_out?: string;
      /** @description Price impact of the estimated swap, if present.  Measured in percentage e.g. "0.5" is .5% */
      swap_price_impact_percent?: string | null;
      /** @description Indicates if the route is unsafe due to poor execution price or if safety cannot be determined due to lack of pricing information */
      warning?: {
        type?: components["schemas"]["RoutePriceWarningType"];
        /** @description Warning message */
        message?: string;
      } | null;
    };
    SendTokenError: {
      /** @description Error message */
      message?: string;
      type?: components["schemas"]["SendTokenErrorType"];
    };
    /**
     * @description SendToken error types: <br/> * SEND_TOKEN_EXECUTION_ERROR - Error occurred during the execute transaction <br/>
     *
     * @enum {string}
     */
    SendTokenErrorType: "SEND_TOKEN_EXECUTION_ERROR";
    SendTokenTxs: {
      confirm_tx?: components["schemas"]["PacketTransaction"] | null;
      error?: components["schemas"]["SendTokenError"] | null;
      execute_tx?: components["schemas"]["PacketTransaction"] | null;
      send_tx?: components["schemas"]["PacketTransaction"] | null;
    };
    StatusError: {
      details?: components["schemas"]["TransactionExecutionErrorDetails"] | null;
      /** @description Error message */
      message?: string;
      type?: components["schemas"]["StatusErrorType"];
    };
    /**
     * @description Packet error type: <br/> * STATUS_ERROR_UNKNOWN - Unknown error <br/> * STATUS_ERROR_TRANSACTION_EXECUTION - Error was encountered during transaction execution <br/> * STATUS_ERROR_INDEXING - Error was encountered while indexing the transaction and packet data <br/> * STATUS_ERROR_TRANSFER - The transfer failed to complete successfully <br/>
     *
     * @enum {string}
     */
    StatusErrorType: "STATUS_ERROR_UNKNOWN" | "STATUS_ERROR_TRANSACTION_EXECUTION" | "STATUS_ERROR_INDEXING" | "STATUS_ERROR_TRANSFER";
    Swap: {
      /** @description Estimated total affiliate fee generated by the swap */
      estimated_affiliate_fee?: string;
    } & (components["schemas"]["SwapInWrapper"] | components["schemas"]["SwapOutWrapper"]);
    /** @description Specification of a swap with an exact amount in */
    SwapExactCoinIn: {
      /** @description Amount to swap in */
      swap_amount_in?: string | null;
      /** @description Operations required to execute the swap */
      swap_operations?: components["schemas"]["SwapOperation"][];
      /** @description Swap venue that this swap should execute on */
      swap_venue?: components["schemas"]["SwapVenue"];
      /** @description Price impact of the estimated swap, if present.  Measured in percentage e.g. "0.5" is .5% */
      price_impact_percent?: string | null;
    };
    /** @description Specification of a swap with an exact amount out */
    SwapExactCoinOut: {
      /** @description Amount to get out of the swap */
      swap_amount_out?: string;
      /** @description Operations required to execute the swap */
      swap_operations?: components["schemas"]["SwapOperation"][];
      /** @description Swap venue that this swap should execute on */
      swap_venue?: components["schemas"]["SwapVenue"];
      /** @description Price impact of the estimated swap, if present.  Measured in percentage e.g. "0.5" is .5% */
      price_impact_percent?: string | null;
    };
    SwapInWrapper: {
      swap_in?: components["schemas"]["SwapExactCoinIn"];
    };
    /** @description Description of a single swap operation */
    SwapOperation: {
      /** @description Input denom of the swap */
      denom_in?: string;
      /** @description Output denom of the swap */
      denom_out?: string;
      /** @description Identifier of the pool to use for the swap */
      pool?: string;
    };
    SwapOutWrapper: {
      swap_out?: components["schemas"]["SwapExactCoinOut"];
    };
    /** @description A venue on which swaps can be exceuted */
    SwapVenue: {
      /** @description Chain-id of the swap venue */
      chain_id?: string;
      /** @description Name of the swap venue */
      name?: string;
    };
    SwapWrapper: {
      swap?: components["schemas"]["Swap"];
    };
    TransactionExecutionErrorDetails: {
      /** @description Error code */
      code?: number;
      /** @description Error message */
      message?: string;
    };
    /**
     * @description Transaction state: <br/> * STATE_SUBMITTED - The initial transaction has been submitted to Skip API but not observed on chain yet. <br/> * STATE_PENDING - The initial transaction has been observed on chain, and there are still pending actions. <br/> * STATE_RECEIVED - The transfer asset has been released, but there are still packet events that are not indexed. <br/> * STATE_COMPLETED_SUCCESS - The initial transaction and any subsequent transfers have completed successfully and lifecycle tracking has concluded. <br/> * STATE_COMPLETED_ERROR - The initial transaction or a subsequent transfer failed and lifecycle tracking has concluded. <br/> * STATE_ABANDONED - Tracking for the transaction has been abandoned. This happens if the cross-chain  sequence of actions stalls for more than 10 minutes or if the initial transaction does not get observed in a block for 5 minutes.
     *
     * @enum {string}
     */
    TransactionState: "STATE_SUBMITTED" | "STATE_PENDING" | "STATE_RECEIVED" | "STATE_COMPLETED_SUCCESS" | "STATE_COMPLETED_ERROR" | "STATE_ABANDONED";
    /** @description A cross-chain transfer */
    Transfer: {
      /** @description Chain-id on which the transfer is initiated */
      chain_id?: string;
      /** @description Channel to use to initiate the transfer */
      channel?: string;
      /** @description Denom of the destionation asset of the transfer */
      dest_denom?: string;
      /** @description Whether pfm is enabled on the chain where the transfer is initiated */
      pfm_enabled?: boolean;
      /** @description Port to use to initiate the transfer */
      port?: string;
      /** @description Whether the transfer chain supports a memo */
      supports_memo?: boolean;
      /** @description Amount of the fee asset to be paid as the transfer fee if applicable. */
      fee_amount?: string | null;
      /** @description Amount of the fee asset to be paid as the transfer fee if applicable, converted to USD value */
      usd_fee_amount?: string | null;
      /** @description Asset to be paid as the transfer fee if applicable. */
      fee_asset?: components["schemas"]["Asset"];
      bridge_id?: components["schemas"]["BridgeType"];
    };
    TransferEvent: components["schemas"]["IBCTransferInfo"] | components["schemas"]["AxelarTransferInfo"] | components["schemas"]["CCTPTransferInfo"];
    TransferInfo: {
      /** @description Chain ID of the destination chain */
      dst_chain_id?: string;
      packet_txs?: components["schemas"]["Packet"];
      /** @description Chain ID of the source chain */
      src_chain_id?: string;
      state?: components["schemas"]["TransferState"];
    };
    /**
     * @description Transfer state: <br/> * TRANSFER_UNKNOWN - Transfer state is not known. <br/> * TRANSFER_PENDING - The send packet for the transfer has been committed and the transfer is pending. <br/> * TRANSFER_RECEIVED - The transfer packet has been received by the destination chain. It can still fail and revert if it is part  of a multi-hop PFM transfer. <br/> * TRANSFER_SUCCESS - The transfer has been successfully completed and will not revert. <br/> * TRANSFER_FAILURE - The transfer has failed.
     *
     * @enum {string}
     */
    TransferState: "TRANSFER_UNKNOWN" | "TRANSFER_PENDING" | "TRANSFER_RECEIVED" | "TRANSFER_SUCCESS" | "TRANSFER_FAILURE";
    TransferStatus: {
      error?: components["schemas"]["StatusError"] | null;
      /** @description Indicates which entry in the `transfer_sequence` field that the transfer is blocked on. Will be null if there is no blocked transfer. */
      next_blocking_transfer?: {
        /** @description The index of the entry in the `transfer_sequence` field that the transfer is blocked on. */
        transfer_sequence_index?: number;
        transfer_state?: components["schemas"]["BlockingTransferState"];
      } | null;
      state?: components["schemas"]["TransactionState"];
      /** @description Indicates location and denom of transfer asset release. */
      transfer_asset_release?: {
        /** @description The chain ID of the chain that the transfer asset is released on. */
        chain_id?: string;
        /** @description The denom of the asset that is released. */
        denom?: string;
      } | null;
      /** @description Lists any IBC and Axelar transfers as they are seen. */
      transfer_sequence?: components["schemas"]["TransferEvent"][];
    };
    TransferWrapper: {
      transfer?: components["schemas"]["Transfer"];
    };
    /**
     * @description Blocking transfer state: <br/> * TRANSFER_PROPAGATING - Transfer is propagating forwards. <br/> * ERROR_PROPAGATING - An error in the transfer sequence is propagating backwards.
     *
     * @enum {string}
     */
    BlockingTransferState: "TRANSFER_PROPAGATING" | "ERROR_PROPAGATING";
    RecommendationRequest: {
      /** @description Denom of the source asset */
      source_asset_denom?: string;
      /** @description Chain-id of the source asset */
      source_asset_chain_id?: string;
      /** @description Chain-id of the recommended destination asset */
      dest_chain_id?: string | null;
      /** @description Reason for recommendation (optional) */
      reason?: components["schemas"]["Reason"] | null;
    };
    CosmosModuleSupport: {
      /** @description Whether the authz module is supported */
      authz?: boolean;
      /** @description Whether the feegrant module is supported */
      feegrant?: boolean;
    };
    IbcCapabilities: {
      /** @description Whether the packet forwarding middleware module is supported */
      cosmos_pfm?: boolean;
      /** @description Whether the ibc hooks module is supported */
      cosmos_ibc_hooks?: boolean;
      /** @description Whether the chain supports IBC memos */
      cosmos_memo?: boolean;
      /** @description Whether the autopilot module is supported */
      cosmos_autopilot?: boolean;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** @description Get all supported chains along with additional data useful for building applications + frontends that interface with them (e.g. logo URI, IBC capabilities, fee assets, bech32 prefix, etc...) */
  getChains: {
    parameters: {
      query?: {
        /**
         * @description Whether to include EVM chains in the response
         * @example false
         */
        include_evm?: boolean;
        /**
         * @description Whether to include testnets in the response
         * @example false
         */
        include_testnets?: boolean;
        /**
         * @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...)
         * @example skip-api-docs
         */
        client_id?: string;
      };
    };
    responses: {
      /** @description Returns a list of supported chains with additional data */
      200: {
        content: {
          "application/json": {
            /** @description Array of supported chain-ids */
            chains?: components["schemas"]["Chain"][];
          };
        };
      };
    };
  };
  /** @description Get all supported bridges */
  getBridges: {
    parameters: {
      query?: {
        /**
         * @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...)
         * @example skip-api-docs
         */
        client_id?: string;
      };
    };
    responses: {
      /** @description A list of supported bridges */
      200: {
        content: {
          "application/json": {
            /** @description Array of supported bridges */
            bridges?: components["schemas"]["Bridge"][];
          };
        };
      };
    };
  };
  /** @description Get supported swap venues. */
  getVenues: {
    responses: {
      /** @description A list of supported swap venues */
      200: {
        content: {
          "application/json": {
            /** @description Array of supported swap venues */
            venues?: components["schemas"]["SwapVenue"][];
          };
        };
      };
    };
  };
  /** @description Get supported assets. Optionally limit to assets on a given chain and/or native assets. */
  getAssets: {
    parameters: {
      query?: {
        /** @description Chain-id to get supported assets for */
        chain_id?: string;
        /** @description Whether to restrict assets to those native to their chain */
        native_only?: boolean;
        /** @description Whether to include assets without metadata (symbol, name, logo_uri, etc.) */
        include_no_metadata_assets?: boolean;
        /** @description Whether to include CW20 tokens */
        include_cw20_assets?: boolean;
        /** @description Whether to include EVM tokens */
        include_evm_assets?: boolean;
        /** @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...) */
        client_id?: string;
      };
    };
    responses: {
      /** @description A map of chain_id to assets */
      200: {
        content: {
          "application/json": {
            /** @description Map of chain-ids to array of assets supported on the chain */
            chain_to_assets_map?: {
              [key: string]: {
                assets?: components["schemas"]["Asset"][];
              };
            };
          };
        };
      };
      /** @description The request was invalid, e.g. field is invalid */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description Get assets that can be reached from a source via transfers under different conditions (e.g. single vs multiple txs) */
  getAssetsFromSource: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Denom of the source asset */
          source_asset_denom: string;
          /** @description Chain-id of the source asset */
          source_asset_chain_id: string;
          /**
           * @description Whether to include recommendations requiring multiple transactions to reach the destination
           * @default false
           */
          allow_multi_tx?: boolean;
          /**
           * @description Whether to include CW20 tokens
           * @default false
           */
          include_cw20_assets?: boolean;
          /** @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...) */
          client_id?: string;
        };
      };
    };
    responses: {
      /** @description Assets reachable from the specified source without swapping */
      200: {
        content: {
          "application/json": {
            /** @description Array of assets that are reachable from the specified source asset */
            dest_assets?: {
              [key: string]: {
                assets?: components["schemas"]["Asset"][];
              };
            };
          };
        };
      };
      /** @description The request was invalid, e.g. field is invalid */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description This supports cross-chain actions among EVM chains, Cosmos chains, and between them. Returns the sequence of transfers and/or swaps to reach the given destination asset from the given source asset, along with estimated amount out. Commonly called before /msgs to generate route info and quote. */
  getRouteV2: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Amount of source asset to be transferred or swapped. Only one of amount_in and amount_out should be provided. */
          amount_in?: string;
          /** @description Amount of destination asset to receive. Only one of amount_in and amount_out should be provided. If amount_out is provided for a swap, the route will be computed to give exactly amount_out. */
          amount_out?: string;
          /** @description Denom of the source asset */
          source_asset_denom?: string;
          /** @description Chain-id of the source asset */
          source_asset_chain_id?: string;
          /** @description Denom of the destination asset */
          dest_asset_denom?: string;
          /** @description Chain-id of the destination asset */
          dest_asset_chain_id?: string;
          /** @description Cumulative fee to be distributed to affiliates, in bps (optional) */
          cumulative_affiliate_fee_bps?: string | null;
          /** @description Swap venue to use, if provided (optional) */
          swap_venue?: components["schemas"]["SwapVenue"];
          /** @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...) */
          client_id?: string;
          /** @description Whether to allow route responses requiring multiple transactions */
          allow_multi_tx?: boolean;
          /** @description Toggles whether the api should return routes that fail price safety checks. */
          allow_unsafe?: boolean;
          /** @description Array of experimental features to enable */
          experimental_features?: string[];
          /** @description Array of bridges to use */
          bridges?: components["schemas"]["BridgeType"][];
        };
      };
    };
    responses: {
      /** @description Swap and transfer route summary & quote */
      200: {
        content: {
          "application/json": components["schemas"]["RouteResponse"];
        };
      };
      /** @description The request was invalid, e.g. an invalid amount was passed or the swap size is unsafe */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description This supports cross-chain actions among EVM chains, Cosmos chains, and between them. Returns minimal number of messages required to execute a multi-chain swap or transfer. Input consists of the output of route with additional information required for message construction (e.g. destination addresses for each chain) */
  getMsgsV2: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Denom of the source asset */
          source_asset_denom?: string;
          /** @description Chain-id of the source asset */
          source_asset_chain_id?: string;
          /** @description Denom of the destination asset */
          dest_asset_denom?: string;
          /** @description Chain-id of the destination asset */
          dest_asset_chain_id?: string;
          /** @description Amount of source asset to be transferred or swapped */
          amount_in?: string;
          /** @description Amount of destination asset out */
          amount_out?: string;
          /** @description Array of receipient and/or sender address for each chain in the path, corresponding to the chain_ids array returned from a route request */
          address_list?: string[];
          /** @description Array of operations required to perform the transfer or swap */
          operations?: components["schemas"]["Operation"][];
          /** @description Percent tolerance for slippage on swap, if a swap is performed */
          slippage_tolerance_percent?: string;
          /** @description Number of seconds for the IBC transfer timeout, defaults to 5 minutes */
          timeout_seconds?: string;
          post_route_handler?: components["schemas"]["PostHandler"];
          /** @description Array of affiliates to send affiliate fees */
          affiliates?: components["schemas"]["Affiliate"][];
        };
      };
    };
    responses: {
      /** @description The messages required to execute the swap, as JSON. */
      200: {
        content: {
          "application/json": {
            msgs?: components["schemas"]["Msg"][];
          };
        };
      };
      /** @description The request was invalid, e.g. an invalid amount was passed. */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description This supports cross-chain actions among EVM chains, Cosmos chains, and between them. Returns minimal number of messages required to execute a multi-chain swap or transfer. This is a convenience endpoint that combines /route and /msgs into a single call. */
  getMsgsDirectV2: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Denom of the source asset */
          source_asset_denom?: string;
          /** @description Chain-id of the source asset */
          source_asset_chain_id?: string;
          /** @description Denom of the destination asset */
          dest_asset_denom?: string;
          /** @description Chain-id of the destination asset */
          dest_asset_chain_id?: string;
          /** @description Amount of source asset to be transferred or swapped. If this is a swap, only one of amount_in and amount_out should be provided. */
          amount_in?: string;
          /** @description Amount of destination asset out. If this is a swap, only one of amount_in and amount_out should be provided. If amount_out is provided for a swap, the route will be computed to give exactly amount_out. */
          amount_out?: string;
          /** @description Map of chain-ids to receipient and/or sender address for each chain in the path. Since the path is not known to the caller beforehand, the caller should attempt to provide addresses for all chains in the path, and the API will return an error if the path cannot be constructed. */
          chain_ids_to_addresses?: {
            [key: string]: string;
          };
          /** @description The swap venue to use, if this request is for a swap (optional) */
          swap_venue?: components["schemas"]["SwapVenue"] | null;
          /** @description Percent tolerance for slippage on swap, if a swap is performed */
          slippage_tolerance_percent?: string;
          /** @description Number of seconds for the IBC transfer timeout, defaults to 5 minutes */
          timeout_seconds?: string;
          /** @description Array of affiliates to send affiliate fees */
          affiliates?: components["schemas"]["Affiliate"][];
          post_route_handler?: components["schemas"]["PostHandler"];
          /** @description Whether to allow route responses requiring multiple transactions */
          allow_multi_tx?: boolean;
          /** @description Toggles whether the api should return routes that fail price safety checks. */
          allow_unsafe?: boolean;
          /** @description Array of experimental features to enable */
          experimental_features?: string[];
          /** @description Array of bridges to use */
          bridges?: components["schemas"]["BridgeType"][];
        };
      };
    };
    responses: {
      /** @description The messages required to execute the swap, as JSON. */
      200: {
        content: {
          "application/json": {
            msgs?: components["schemas"]["Msg"][];
            route?: components["schemas"]["RouteResponse"];
          };
        };
      };
      /** @description The request was invalid, e.g. an invalid amount was passed or the swap size is unsafe */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description Request asset recommendations for the given source assets on a given destination chain. The response includes recommended destination assets and recommendation reasons. */
  getAssetRecommendations: {
    requestBody: {
      content: {
        /**
         * @example {
         *   "requests": [
         *     {
         *       "source_asset_denom": "uusdc",
         *       "source_asset_chain_id": "axelar-dojo-1",
         *       "dest_chain_id": "cosmoshub-4"
         *     },
         *     {
         *       "source_asset_denom": "uusdc",
         *       "source_asset_chain_id": "axelar-dojo-1",
         *       "dest_chain_id": "osmosis-1"
         *     }
         *   ],
         *   "client_id": "skip-api-docs"
         * }
         */
        "application/json": {
          /** @description Array where each entry corresponds to a distinct asset recommendation request. */
          requests?: components["schemas"]["RecommendationRequest"][];
        };
      };
    };
    responses: {
      /** @description Recommended destination assets and reasons */
      200: {
        content: {
          "application/json": {
            /** @description Array of recommendations for each entry in the `request` field. */
            recommendation_entries?: {
                recommendations?: components["schemas"]["AssetRecommendation"][];
                error?: components["schemas"]["ApiError"];
              }[];
          };
        };
      };
      /** @description The request was invalid, i.e. required fields are missing */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description A recommendation or the specified token was not found */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description Submit a signed base64 encoded transaction to be broadcast to the specified network. On successful submission, the status of the transaction and any subsequent IBC or Axelar transfers can be queried through the /status endpoint. */
  submitTransactionV2: {
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Signed base64 encoded transaction
           * @example base64 encoded transaction
           */
          tx?: string;
          /**
           * @description Chain ID of the transaction
           * @example osmosis-1
           */
          chain_id?: string;
          /**
           * @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...)
           * @example skip-api-docs
           */
          client_id?: string;
        };
      };
    };
    responses: {
      /** @description The hash of the transaction. */
      200: {
        content: {
          "application/json": {
            /** @description Hash of the transaction */
            tx_hash?: string;
          };
        };
      };
      /** @description The request was invalid, i.e. the submitted transaction was malformed or fails on execution. */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description The specified chain is not supported. */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description Requests tracking of a transaction that has already landed on-chain but was not broadcast through the skip api. The status of a tracked transaction and subsequent IBC or Axelar transfers if routing assets cross chain can be queried through the /status endpoint. */
  trackTransactionV2: {
    requestBody: {
      content: {
        "application/json": {
          /**
           * @description Hex encoded hash of the transaction to track
           * @example tx hash
           */
          tx_hash?: string;
          /**
           * @description Chain ID of the transaction
           * @example osmosis-1
           */
          chain_id?: string;
          /**
           * @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...)
           * @example skip-api-docs
           */
          client_id?: string;
        };
      };
    };
    responses: {
      /** @description The hash of the transaction. */
      200: {
        content: {
          "application/json": {
            /** @description Hash of the transaction */
            tx_hash?: string;
          };
        };
      };
      /** @description The request was invalid, i.e. the transaction hash was malformed or the specified transaction did not execute successfully. */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description The specified chain is not supported or the specified transaction was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description Get the status of the specified transaction and any subsequent IBC or Axelar transfers if routing assets cross chain. The transaction must have previously been submitted to either the /submit or /track endpoints. */
  getTransactionStatusV2: {
    parameters: {
      query: {
        /**
         * @description Hex encoded hash of the transaction to query for
         * @example EEC65138E6A7BDD047ED0D4BBA249A754F0BBBC7AA976568C4F35A32CD7FB8EB
         */
        tx_hash: string;
        /**
         * @description Chain ID of the transaction
         * @example cosmoshub-4
         */
        chain_id: string;
        /**
         * @description Recognizable identifier for callers (e.g. skip-api-docs, best-wallet, etc...)
         * @example skip-api-docs
         */
        client_id?: string;
      };
    };
    responses: {
      /** @description The status of the transaction and any subsequent ibc or Axelar transfers. */
      200: {
        content: {
          "application/json": {
            /** @description Transfer status for all transfers initiated by the transaction in the order they were initiated. */
            transfers?: components["schemas"]["TransferStatus"][];
          };
        };
      };
      /** @description The specified tx was not found. */
      404: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
  /** @description Get origin assets from a given list of denoms and chain ids. */
  getOriginAssets: {
    requestBody: {
      content: {
        "application/json": {
          /** @description Array of assets to get origin assets for */
          assets?: {
              /** @description Denom of the asset */
              denom?: string;
              /** @description Chain-id of the asset */
              chain_id?: string;
            }[];
        };
      };
    };
    responses: {
      /** @description The origin assets of the specified denoms and chain ids. */
      200: {
        content: {
          "application/json": {
            origin_assets?: components["schemas"]["OptionalAsset"][];
          };
        };
      };
      /** @description The request was invalid, i.e. required fields are missing */
      400: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
      /** @description Internal server error */
      500: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
}
